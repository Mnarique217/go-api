package main

import (
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"time"

	pb "github.com/Mnarique217/go-api/booksapp"
	"google.golang.org/grpc"
)

var books []Book
var bookIDs []string

func main() {
	address := "localhost:8080" //os.Getenv("ADDRESS")
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	c := pb.NewBookInfoClient(conn)
	/*ADD*/
	actionPerformed("ADD BOOK")
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := c.AddBook(ctx, &pb.Book{
		Id:        "1",
		Title:     "Operating System Concepts",
		Edition:   "9th",
		Copyright: "2012",
		Language:  "ENGLISH",
		Pages:     "976",
		Author:    "Abraham Silberschatz",
		Publisher: "John Wiley & Sons"})
	if err != nil {
		log.Fatalf("Could not add book: %v", err)
	}
	bookIDs = append(bookIDs, r.Value)

	/*UPDATE*/
	actionPerformed("UPDATE BOOK")
	bookData := &pb.Book{
		Id:        "1",
		Title:     "UPDATED TITLE",
		Edition:   "10th",
		Copyright: "2052",
		Language:  "ESPANOL",
		Pages:     "800",
		Author:    "MANRIQUE",
		Publisher: "MANRIQUE"}
	idToUpdate := &pb.BookID{Value: r.Value}
	bkUpdate := &pb.BookUpdate{Update: bookData, Id: idToUpdate}

	bookResult, err := c.UpdateBook(ctx, bkUpdate)
	if err != nil {
		log.Fatalf("Could not get book: %v", err)
	}
	fmt.Println("Result is: ")
	fmt.Println(bookResult.String())

	/*GET*/
	actionPerformed("GET BOOK")
	book1, err := c.GetBook(ctx, &pb.BookID{Value: r.Value})
	if err != nil {
		log.Fatalf("Could not get book: %v", err)
	}
	fmt.Println("Result is: ")
	fmt.Println(book1.String())

	/*DELETE*/
	actionPerformed("DELETE BOOK")
	result, err := c.DeleteBook(ctx, &pb.BookID{Value: r.Value})
	if err != nil {
		log.Fatalf("Could not delete the book: %v", err)
	}
	fmt.Println("Result is: ")
	fmt.Println(result.String())

	/* load CSV*/
	actionPerformed("csv")
	readData("books.csv")
	for _, book := range books {

		r, err := c.AddBook(ctx, &pb.Book{
			Id:        book.Id,
			Title:     book.Title,
			Edition:   book.Edition,
			Copyright: book.Copyright,
			Language:  book.Language,
			Pages:     book.Pages,
			Author:    book.Author,
			Publisher: book.Publisher})
		if err != nil {
			log.Fatalf("Could not add book: %v", err)
		}
		bookIDs = append(bookIDs, r.Value)
	}
	fmt.Println(bookIDs)
}

func addBoocks() {

}

func actionPerformed(title string) {
	fmt.Println("")
	fmt.Println("=======================================")
	fmt.Println("               ", title, "             ")
	fmt.Println("=======================================")
}

type Book struct {
	Id        string `json:"id"`
	Title     string `json:"title"`
	Edition   string `json:"edition"`
	Copyright string `json:"copyright"`
	Language  string `json:"language"`
	Pages     string `json:"pages"`
	Author    string `json:"author"`
	Publisher string `json:"publisher"`
}

func checkError(message string, err error) {
	if err != nil {
		log.Fatal(message, err)
	}
}

func readData(filePath string) {
	file, err1 := os.Open(filePath)
	checkError("Unable to read input file "+filePath, err1)
	defer file.Close()

	csvReader := csv.NewReader(file)
	records, err2 := csvReader.ReadAll()
	checkError("Unable to parse file as CSV for "+filePath, err2)
	defer file.Close()

	books = []Book{}

	for _, record := range records {
		book := Book{
			Id:        record[0],
			Title:     record[1],
			Edition:   record[2],
			Copyright: record[3],
			Language:  record[4],
			Pages:     record[5],
			Author:    record[6],
			Publisher: record[7]}
		books = append(books, book)
	}
	file.Close()
}
